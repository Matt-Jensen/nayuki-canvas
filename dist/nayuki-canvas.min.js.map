{"version":3,"sources":["nayuki-canvas.js","utils.js","disjoint-set.js","index.js"],"names":["containsEdge","array","edge","i","length","elem","nodeA","nodeB","redrawCanvas","canvasElem","graphics","nodes","edges","width","height","size","Math","max","gradient","createRadialGradient","addColorStop","fillStyle","fillRect","forEach","node","opacity","toFixed","beginPath","arc","posX","posY","radius","PI","fill","lineWidth","dx","dy","mag","hypot","min","strokeStyle","moveTo","lineTo","stroke","DisjointSet","getRepr","parents","ranks","push","this","mergeSets","j","repr0","repr1","cmp","_typeof","Symbol","iterator","obj","constructor","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","next","done","value","err","Array","isArray","Object","TypeError","BORDER_FADE","FADE_IN_RATE","FADE_OUT_RATE","FRAME_INTERVAL","networkStyleKey","mesh","balanced","hubAndSpoke","nayukiCanvas","create","options","HTMLElement","nodeName","Error","config","assign","extraEdges","numNodes","networkStyle","driftSpeed","repulsionForce","proto","core","canvas","idealNumNodes","get","parseInt","maxExtraEdges","_config","round","parseFloat","radiiWeightPower","temp","isNaN","set","getContext","setTimeout","stepFrame","bind","updateNodes","updateEdges","_initialize","doForceField","concat","item","pixWidth","pixHeight","relWidth","relHeight","newNodes","index","velX","velY","random","pow","allEdges","calcAllEdgeWeights","idealEdges","calcSpanningTree","newEdges","_edge","deltas","distSqr","factor","sqrt","result","weight","sort","a","b","_a","x","_b","y","ds","k","exports","module","define","amd","window"],"mappings":"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","file":"nayuki-canvas.min.js","sourcesContent":["import {\n  containsEdge,\n  redrawCanvas\n} from './utils'\nimport DisjointSet from './disjoint-set'\n\n// TODO make options\nvar BORDER_FADE = -0.02;\nvar FADE_IN_RATE  = 0.06;  // In the range (0.0, 1.0]\nvar FADE_OUT_RATE = 0.03;  // In the range (0.0, 1.0]\nvar FRAME_INTERVAL = 20;  // In milliseconds\n\nconst networkStyleKey = {\n  mesh: 0,\n  balanced: 0.5,\n  hubAndSpoke: 1\n};\n\nconst nayukiCanvas = {\n  create(canvasElem, options) {\n\n    if (canvasElem instanceof HTMLElement === false || canvasElem.nodeName !== 'CANVAS') {\n      throw new Error('Nayuki Canvas requires a canvas DOM node as the first argument');\n    }\n\n    // Overwrite config with user options\n    const config = Object.assign({\n      extraEdges: 20,\n      numNodes: 70,\n      networkStyle: 'balanced',\n      driftSpeed: 1,\n      repulsionForce: 1\n    }, options);\n    const proto = Object.assign({}, { config }, nayukiCanvas.core);\n    const canvas = Object.create(proto, {\n      idealNumNodes: {\n        get() {\n          return parseInt(this.config.numNodes, 10);\n        }\n      },\n      maxExtraEdges: {\n        get() {\n          const { extraEdges, numNodes } = this.config;\n          return Math.round(parseFloat(extraEdges) / 100 * numNodes);\n        }\n      },\n      radiiWeightPower: {\n        get() {\n          const { networkStyle } = this.config;\n          const radiiWeightPower = networkStyleKey[networkStyle];\n          return parseFloat(radiiWeightPower);\n        }\n      },\n      driftSpeed: {\n        get() {\n          const temp = this.config.driftSpeed;\n          if (!isNaN(temp)) {\n            return temp * 0.0001;\n          }\n        },\n        set(value) {\n          this.config.driftSpeed = parseFloat(value);\n          return this.driftSpeed;\n        }\n      },\n      repulsionForce: {\n        get() {\n          const temp = this.config.repulsionForce;\n          if (!isNaN(temp)) {\n            return temp * 0.000001;\n          }\n        },\n        set(value) {\n          this.config.repulsionForce = parseFloat(value);\n          return this.repulsionForce;\n        }\n      }\n    });\n    canvas.canvasElem = canvasElem;\n\n    // Initialize canvas and inputs\n    const graphics = canvas.graphics = canvasElem.getContext('2d');\n\n    // State of graph nodes - each object has these properties:\n    // - posX: Horizontal position in relative coordinates, typically in the range [0.0, relWidth], where relWidth <= 1.0\n    // - posY: Vertical position in relative coordinates, typically in the range [0.0, relHeight], where relHeight <= 1.0\n    // - velX: Horizontal velocity in relative units (not pixels)\n    // - velY: Vertical velocity in relative units (not pixels)\n    // - radius: Radius of the node, a positive real number\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the node\n    canvas.nodes = [];\n\n    // State of graph edges - each object has these properties:\n    // - nodeA: A reference to the node object representing one side of the undirected edge\n    // - nodeB: A reference to the node object representing another side of the undirected edge (must be distinct from NodeA)\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the edge\n    canvas.edges = [];\n\n    // Periodically execute stepFrame() to create animation\n    setTimeout(canvas.stepFrame.bind(canvas), FRAME_INTERVAL);\n    return canvas;\n  },\n\n  core: {\n\n    // This important top-level function updates the arrays of nodes and edges, then redraws the canvas.\n    // We define it within the closure to give it access to key variables that persist across iterations.\n    stepFrame() {\n      const { canvasElem, graphics } = this;\n      let { nodes, edges } = this;\n      nodes = this.updateNodes(canvasElem.width, canvasElem.height, nodes);\n      edges = this.updateEdges(nodes, edges);\n      redrawCanvas(canvasElem, graphics, nodes, edges);\n    },\n\n    // Populate initial nodes and edges, then improve on them\n    _initialize() {\n      this.stepFrame();  // Generate nodes\n      for (let i = 0; i < 300; i++) {  // Spread out nodes to avoid ugly clumping\n        this.doForceField(nodes);\n      }\n      this.edges = [];\n      this.stepFrame();  // Redo spanning tree and extra edges because nodes have moved\n\n      // Make everything render immediately instead of fading in\n      this.nodes.concat(this.edges).forEach(function(item) {  // Duck typing\n        item.opacity = 1;\n      });\n\n      redrawCanvas(this.canvasElem, this.graphics, this.nodes, this.edges);\n    },\n\n    // Returns a new array of nodes by updating/adding/removing nodes based on the given array. Although the\n    // argument array is not modified, the node objects themselves are modified. No other side effects.\n    updateNodes(pixWidth, pixHeight, nodes) {\n\n      // At least one of relWidth or relHeight is exactly 1. The aspect ratio relWidth:relHeight is equal to w:h.\n      var relWidth  = pixWidth  / Math.max(pixWidth, pixHeight);\n      var relHeight = pixHeight / Math.max(pixWidth, pixHeight);\n\n      // Update position, velocity, opacity; prune faded nodes\n      var newNodes = [];\n      nodes.forEach(function(node, index) {\n\n        // Move based on velocity\n        node.posX += node.velX * driftSpeed;\n        node.posY += node.velY * driftSpeed;\n\n        // Randomly perturb velocity, with damping\n        node.velX = node.velX * 0.99 + (Math.random() - 0.5) * 0.3;\n        node.velY = node.velY * 0.99 + (Math.random() - 0.5) * 0.3;\n\n        if (index >= this.idealNumNodes || node.posX < BORDER_FADE || relWidth - node.posX < BORDER_FADE || node.posY < BORDER_FADE || relHeight - node.posY < BORDER_FADE) {\n\n          // Fade out nodes near the borders of the space or exceeding the target number of nodes\n          node.opacity = Math.max(node.opacity - FADE_OUT_RATE, 0);\n        } else {\n\n           // Fade in ones otherwise\n          node.opacity = Math.min(node.opacity + FADE_IN_RATE, 1);\n        }\n\n        if (node.opacity > 0) {\n\n          // Only keep visible nodes\n          newNodes.push(node);\n        }\n      });\n\n      // Add new nodes to fade in\n      for (let i = newNodes.length; i < this.idealNumNodes; i++) {\n        newNodes.push({ // Random position and radius, other properties initially zero\n          posX: Math.random() * relWidth,\n          posY: Math.random() * relHeight,\n          radius: (Math.pow(Math.random(), 5) + 0.35) * 0.015,  // Skew toward smaller values\n          velX: 0.0,\n          velY: 0.0,\n          opacity: 0.0,\n        });\n      }\n\n      // Spread out nodes a bit\n      this.doForceField(newNodes);\n      return newNodes;\n    },\n\n    // Returns a new array of edges by reading the given array of nodes and by updating/adding/removing edges\n    // based on the other given array. Although both argument arrays and nodes are unmodified,\n    // the edge objects themselves are modified. No other side effects.\n    updateEdges(nodes, edges) {\n      let i = 0;\n\n      // Calculate array of spanning tree edges, then add some extra low-weight edges\n      let allEdges = this.calcAllEdgeWeights(nodes)\n      const idealEdges = this.calcSpanningTree(allEdges, nodes);\n\n      for (i = 0; i < allEdges.length && idealEdges.length < nodes.length - 1 + this.maxExtraEdges; i++) {\n        const edge = { nodeA:nodes[allEdges[i][1]], nodeB:nodes[allEdges[i][2]] };  // Convert data formats\n        if (!containsEdge(idealEdges, edge)) {\n          idealEdges.push(edge);\n        }\n      }\n      allEdges = null;  // Let this big array become garbage sooner\n\n      // Classify each current edge, checking whether it is in the ideal set; prune faded edges\n      const newEdges = [];\n      edges.forEach(function(edge) {\n        if (containsEdge(idealEdges, edge)) {\n          edge.opacity = Math.min(edge.opacity + FADE_IN_RATE, 1);\n        } else {\n          edge.opacity = Math.max(edge.opacity - FADE_OUT_RATE, 0);\n        }\n        if (edge.opacity > 0 && edge.nodeA.opacity > 0 && edge.nodeB.opacity > 0) {\n          newEdges.push(edge);\n        }\n      });\n\n      // If there is room for new edges, add some missing spanning tree edges (higher priority), then extra edges\n      for (i = 0; i < idealEdges.length && newEdges.length < nodes.length - 1 + this.maxExtraEdges; i++) {\n        const edge = idealEdges[i];\n        if (!containsEdge(newEdges, edge)) {\n          edge.opacity = 0.0;  // Add missing property\n          newEdges.push(edge);\n        }\n      }\n\n      return newEdges;\n    },\n\n    // Updates the position of each node in the given array (in place), based on\n    // their existing positions. Returns nothing. No other side effects.\n    doForceField(nodes) {\n      let i = 0;\n      const deltas = [];\n\n      for (i = 0; i < nodes.length * 2; i++) {\n        deltas.push(0.0);\n      }\n\n      // For simplicitly, we perturb positions directly, instead of velocities\n      for (i = 0; i < nodes.length; i++) {\n        const nodeA = nodes[i];\n\n        for (let j = 0; j < i; j++) {\n          const nodeB = nodes[j];\n          let dx = nodeA.posX - nodeB.posX;\n          let dy = nodeA.posY - nodeB.posY;\n          const distSqr = dx * dx + dy * dy;\n\n          // Notes: The factor 1/sqrt(distSqr) is to make (dx, dy) into a unit vector.\n          // 1/distSqr is the inverse square law, with a smoothing constant added to prevent singularity.\n          const factor = this.repulsionForce / (Math.sqrt(distSqr) * (distSqr + 0.00001));\n          dx *= factor;\n          dy *= factor;\n          deltas[i * 2 + 0] += dx;\n          deltas[i * 2 + 1] += dy;\n          deltas[j * 2 + 0] -= dx;\n          deltas[j * 2 + 1] -= dy;\n        }\n      }\n\n      for (i = 0; i < nodes.length; i++) {\n        nodes[i].posX += deltas[i * 2 + 0];\n        nodes[i].posY += deltas[i * 2 + 1];\n      }\n    },\n\n    // Returns a sorted array of edges with weights, for all unique edge pairs. Pure function, no side effects.\n    calcAllEdgeWeights(nodes) {\n\n      // Each entry has the form [weight, nodeAIndex, nodeBIndex], where nodeAIndex < nodeBIndex\n      const result = [];\n\n      for (let i = 0; i < nodes.length; i++) {  // Calculate all n * (n - 1) / 2 edges\n        const nodeA = nodes[i];\n\n        for (let j = 0; j < i; j++) {\n          const nodeB = nodes[j];\n          let weight = Math.hypot(nodeA.posX - nodeB.posX, nodeA.posY - nodeB.posY);  // Euclidean distance\n          weight /= Math.pow(nodeA.radius * nodeB.radius, this.radiiWeightPower);  // Give discount based on node radii\n          result.push([weight, i, j]);\n        }\n      }\n\n      // Sort array by ascending weight\n      result.sort((a, b) => {\n        const [x] = a;\n        const [y] = b;\n        return x < y ? -1 : (x > y ? 1 : 0);\n      });\n\n      return result;\n    },\n\n    // Returns a new array of edge objects that is a minimal spanning tree on the given set\n    // of nodes, with edges in ascending order of weight. Note that the returned edge objects\n    // are missing the opacity property. Pure function, no side effects.\n    calcSpanningTree(allEdges, nodes) {\n\n      // Kruskal's MST algorithm\n      const result = [];\n      const ds = new DisjointSet(nodes.length);\n\n      for (let i = 0; i < allEdges.length && result.length < nodes.length - 1; i++) {\n        const edge = allEdges[i];\n        const j = edge[1];\n        const k = edge[2];\n\n        if (ds.mergeSets(j, k)) {\n          result.push({nodeA:nodes[j], nodeB:nodes[k]});\n        }\n      }\n\n      return result;\n    }\n  }\n};\n\nexport default nayukiCanvas;\n","// Returns a sorted array of edges with weights, for all unique edge pairs. Pure function, no side effects.\nexport function calcAllEdgeWeights(nodes) {\n  // Each entry has the form [weight, nodeAIndex, nodeBIndex], where nodeAIndex < nodeBIndex\n  const result = [];\n\n  for (let i = 0; i < nodes.length; i++) {  // Calculate all n * (n - 1) / 2 edges\n    const nodeA = nodes[i];\n\n    for (let j = 0; j < i; j++) {\n      const nodeB = nodes[j];\n      let weight = Math.hypot(nodeA.posX - nodeB.posX, nodeA.posY - nodeB.posY);  // Euclidean distance\n      weight /= Math.pow(nodeA.radius * nodeB.radius, radiiWeightPower);  // Give discount based on node radii\n      result.push([weight, i, j]);\n    }\n  }\n\n  // Sort array by ascending weight\n  result.sort((a, b) => {\n    const [x] = a;\n    const [y] = b;\n    return x < y ? -1 : (x > y ? 1 : 0);\n  });\n\n  return result;\n}\n\n// Returns a new array of edge objects that is a minimal spanning tree on the given set\n// of nodes, with edges in ascending order of weight. Note that the returned edge objects\n// are missing the opacity property. Pure function, no side effects.\nexport function calcSpanningTree(allEdges, nodes) {\n\n  // Kruskal's MST algorithm\n  const result = [];\n  const ds = new DisjointSet(nodes.length);\n\n  for (let i = 0; i < allEdges.length && result.length < nodes.length - 1; i++) {\n    const edge = allEdges[i];\n    const j = edge[1];\n    const k = edge[2];\n\n    if (ds.mergeSets(j, k)) {\n      result.push({nodeA:nodes[j], nodeB:nodes[k]});\n    }\n  }\n\n  return result;\n}\n\n// Tests whether the given array of edge objects contains an edge with\n// the given endpoints (undirected). Pure function, no side effects.\nexport function containsEdge(array, edge) {\n  for (let i = 0; i < array.length; i++) {\n    const elem = array[i];\n    if (elem.nodeA == edge.nodeA && elem.nodeB == edge.nodeB || elem.nodeA == edge.nodeB && elem.nodeB == edge.nodeA) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Redraws the canvas based on the given values. No other side effects.\nexport function redrawCanvas(canvasElem, graphics, nodes, edges) {\n\n  // Get pixel dimensions\n  const { width, height } = canvasElem;\n  const size = Math.max(width, height);\n\n  // Draw background gradient to overwrite everything\n  const gradient = graphics.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, size / 2);\n  gradient.addColorStop(0.0, '#575E85');\n  gradient.addColorStop(1.0, '#2E3145');\n  graphics.fillStyle = gradient;\n  graphics.fillRect(0, 0, width, height);\n\n  // Draw every node\n  nodes.forEach((node) => {\n    graphics.fillStyle = `rgba(129,139,197,${node.opacity.toFixed(3)})`;\n    graphics.beginPath();\n    graphics.arc(node.posX * size, node.posY * size, node.radius * size, 0, Math.PI * 2);\n    graphics.fill();\n  });\n\n  // Draw every edge\n  graphics.lineWidth = size / 800;\n  edges.forEach((edge) => {\n    const { nodeA, nodeB } = edge;\n    let dx = nodeA.posX - nodeB.posX;\n    let dy = nodeA.posY - nodeB.posY;\n    const mag = Math.hypot(dx, dy);\n\n    if (mag > nodeA.radius + nodeB.radius) {  // Draw edge only if circles don't intersect\n      dx /= mag;  // Make (dx, dy) a unit vector, pointing from B to A\n      dy /= mag;\n\n      const opacity = Math.min(Math.min(nodeA.opacity, nodeB.opacity), edge.opacity);\n      graphics.strokeStyle = `rgba(129,139,197,${opacity.toFixed(3)})`;\n      graphics.beginPath();\n\n      // Shorten the edge so that it only touches the circumference of each circle\n      graphics.moveTo((nodeA.posX - dx * nodeA.radius) * size, (nodeA.posY - dy * nodeA.radius) * size);\n      graphics.lineTo((nodeB.posX + dx * nodeB.radius) * size, (nodeB.posY + dy * nodeB.radius) * size);\n      graphics.stroke();\n    }\n  });\n}\n","// The union-find data structure. A heavily stripped-down version derived from https://www.nayuki.io/page/disjoint-set-data-structure .\nexport default function DisjointSet(size) {\n  const parents = [];\n  const ranks = [];\n\n  for (let i = 0; i < size; i++) {\n    parents.push(i);\n    ranks.push(0);\n  }\n\n  function getRepr(i) {\n    if (parents[i] != i) {\n      parents[i] = getRepr(parents[i]);\n    }\n    return parents[i];\n  }\n\n  this.mergeSets = function(i, j) {\n    const repr0 = getRepr(i);\n    const repr1 = getRepr(j);\n\n    if (repr0 == repr1) {\n      return false;\n    }\n\n    const cmp = ranks[repr0] - ranks[repr1];\n    if (cmp >= 0) {\n      if (cmp == 0) {\n        ranks[repr0]++;\n      }\n      parents[repr1] = repr0;\n    } else {\n      parents[repr0] = repr1;\n    }\n\n    return true;\n  };\n}\n","import nayukiCanvas from './nayuki-canvas';\n\nif (typeof exports === 'object') {\n  module.exports = nayukiCanvas;\n} else if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n  define(function() { return nayukiCanvas; });\n} else if (window && !window.nayukiCanvas) {\n  window.nayukiCanvas = nayukiCanvas;\n}\n"],"sourceRoot":"/source/"}