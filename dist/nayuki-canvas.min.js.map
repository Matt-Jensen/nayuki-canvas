{"version":3,"sources":["nayuki-canvas.js","utils.js","index.js"],"names":["calcAllEdgeWeights","nodes","result","i","length","nodeA","j","nodeB","weight","Math","hypot","posX","posY","pow","radius","radiiWeightPower","push","sort","a","b","_a","_slicedToArray","x","_b","y","calcSpanningTree","allEdges","ds","DisjointSet","edge","k","mergeSets","containsEdge","array","elem","doForceField","deltas","dx","dy","distSqr","factor","repulsionForce","sqrt","updateEdges","edges","idealEdges","maxExtraEdges","newEdges","forEach","opacity","min","FADE_IN_RATE","max","FADE_OUT_RATE","_edge","redrawCanvas","canvasElem","graphics","width","height","size","gradient","createRadialGradient","addColorStop","fillStyle","fillRect","node","toFixed","beginPath","arc","PI","fill","lineWidth","mag","strokeStyle","moveTo","lineTo","stroke","_typeof","Symbol","iterator","obj","constructor","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","next","done","value","err","Array","isArray","Object","TypeError","BORDER_FADE","networkStyleKey","mesh","balanced","hubAndSpoke","nayukiCanvas","create","options","HTMLElement","nodeName","Error","config","assign","extraEdges","numNodes","networkStyle","driftSpeed","proto","core","canvas","idealNumNodes","get","parseInt","this","_config","round","parseFloat","temp","isNaN","set","el","getContext","updateNodes","pixWidth","pixHeight","relWidth","relHeight","newNodes","index","velX","velY","random","exports","module","define","amd","window"],"mappings":"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","file":"nayuki-canvas.min.js","sourcesContent":["import {\n  calcAllEdgeWeights,\n  calcSpanningTree,\n  containsEdge,\n  doForceField,\n  updateEdges,\n  redrawCanvas\n} from './utils';\n\n// TODO make options\nvar BORDER_FADE = -0.02;\nvar FADE_IN_RATE  = 0.06;  // In the range (0.0, 1.0]\nvar FADE_OUT_RATE = 0.03;  // In the range (0.0, 1.0]\nvar FRAME_INTERVAL = 20;  // In milliseconds\n\nconst networkStyleKey = {\n  mesh: 0,\n  balanced: 0.5,\n  hubAndSpoke: 1\n};\n\nconst nayukiCanvas = {\n  create(canvasElem, options) {\n\n    if (canvasElem instanceof HTMLElement === false || canvasElem.nodeName !== 'CANVAS') {\n      throw new Error('Nayuki Canvas requires a canvas DOM node as the first argument');\n    }\n\n    // Overwrite config with user options\n    const config = Object.assign({\n      extraEdges: 20,\n      numNodes: 70,\n      networkStyle: 'balanced',\n      driftSpeed: 1,\n      repulsionForce: 1\n    }, options);\n    const proto = Object.assign({}, { config }, nayukiCanvas.core);\n    const canvas = Object.create(proto, {\n      idealNumNodes: {\n        get() {\n          return parseInt(this.config.numNodes, 10);\n        }\n      },\n      maxExtraEdges: {\n        get() {\n          const { extraEdges, numNodes } = this.config;\n          return Math.round(parseFloat(extraEdges) / 100 * numNodes);\n        }\n      },\n      radiiWeightPower: {\n        get() {\n          const { networkStyle } = this.config;\n          const radiiWeightPower = networkStyleKey[networkStyle];\n          return parseFloat(radiiWeightPower);\n        }\n      },\n      driftSpeed: {\n        get() {\n          const temp = this.config.driftSpeed;\n          if (!isNaN(temp)) {\n            return temp * 0.0001;\n          }\n        },\n        set(value) {\n          this.config.driftSpeed = parseFloat(value);\n          return this.driftSpeed;\n        }\n      },\n      repulsionForce: {\n        get() {\n          const temp = this.config.repulsionForce;\n          if (!isNaN(temp)) {\n            return temp * 0.000001;\n          }\n        },\n        set(value) {\n          this.config.repulsionForce = parseFloat(value);\n          return this.repulsionForce;\n        }\n      }\n    });\n    canvas.el = canvasElem;\n\n    // Initialize canvas and inputs\n    const graphics = canvas.graphics = canvasElem.getContext('2d');\n\n    // State of graph nodes - each object has these properties:\n    // - posX: Horizontal position in relative coordinates, typically in the range [0.0, relWidth], where relWidth <= 1.0\n    // - posY: Vertical position in relative coordinates, typically in the range [0.0, relHeight], where relHeight <= 1.0\n    // - velX: Horizontal velocity in relative units (not pixels)\n    // - velY: Vertical velocity in relative units (not pixels)\n    // - radius: Radius of the node, a positive real number\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the node\n    let nodes = canvas.nodes = [];\n\n    // State of graph edges - each object has these properties:\n    // - nodeA: A reference to the node object representing one side of the undirected edge\n    // - nodeB: A reference to the node object representing another side of the undirected edge (must be distinct from NodeA)\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the edge\n    let edges = canvas.edges = [];\n\n    // This important top-level function updates the arrays of nodes and edges, then redraws the canvas.\n    // We define it within the closure to give it access to key variables that persist across iterations.\n    function stepFrame() {\n      nodes = updateNodes(canvasElem.width, canvasElem.height, nodes);\n      edges = updateEdges(nodes, edges);\n      redrawCanvas(canvasElem, graphics, nodes, edges);\n    }\n\n    // Populate initial nodes and edges, then improve on them\n    // stepFrame();  // Generate nodes\n    // for (let i = 0; i < 300; i++) {  // Spread out nodes to avoid ugly clumping\n    //   doForceField(nodes);\n    // }\n    // edges = [];\n    // stepFrame();  // Redo spanning tree and extra edges because nodes have moved\n\n    // Make everything render immediately instead of fading in\n    // nodes.concat(edges).forEach(function(item) {  // Duck typing\n    //   item.opacity = 1;\n    // });\n    // redrawCanvias(canvasElem, graphics, nodes, edges);\n\n    // Periodically execute stepFrame() to create animation\n    // setInterval(stepFrame, FRAME_INTERVAL);\n    return canvas;\n  },\n\n  core: {\n    updateNodes(pixWidth, pixHeight, nodes) {\n\n      // At least one of relWidth or relHeight is exactly 1. The aspect ratio relWidth:relHeight is equal to w:h.\n      var relWidth  = pixWidth  / Math.max(pixWidth, pixHeight);\n      var relHeight = pixHeight / Math.max(pixWidth, pixHeight);\n\n      // Update position, velocity, opacity; prune faded nodes\n      var newNodes = [];\n      nodes.forEach(function(node, index) {\n\n        // Move based on velocity\n        node.posX += node.velX * driftSpeed;\n        node.posY += node.velY * driftSpeed;\n\n        // Randomly perturb velocity, with damping\n        node.velX = node.velX * 0.99 + (Math.random() - 0.5) * 0.3;\n        node.velY = node.velY * 0.99 + (Math.random() - 0.5) * 0.3;\n\n        if (index >= idealNumNodes || node.posX < BORDER_FADE || relWidth - node.posX < BORDER_FADE || node.posY < BORDER_FADE || relHeight - node.posY < BORDER_FADE) {\n\n          // Fade out nodes near the borders of the space or exceeding the target number of nodes\n          node.opacity = Math.max(node.opacity - FADE_OUT_RATE, 0);\n        } else {\n\n           // Fade in ones otherwise\n          node.opacity = Math.min(node.opacity + FADE_IN_RATE, 1);\n        }\n\n        if (node.opacity > 0) {\n\n          // Only keep visible nodes\n          newNodes.push(node);\n        }\n      });\n\n      // Add new nodes to fade in\n      for (let i = newNodes.length; i < idealNumNodes; i++) {\n        newNodes.push({ // Random position and radius, other properties initially zero\n          posX: Math.random() * relWidth,\n          posY: Math.random() * relHeight,\n          radius: (Math.pow(Math.random(), 5) + 0.35) * 0.015,  // Skew toward smaller values\n          velX: 0.0,\n          velY: 0.0,\n          opacity: 0.0,\n        });\n      }\n\n      // Spread out nodes a bit\n      doForceField(newNodes);\n      return newNodes;\n    }\n  }\n};\n\nexport default nayukiCanvas;\n","// Returns a sorted array of edges with weights, for all unique edge pairs. Pure function, no side effects.\nexport function calcAllEdgeWeights(nodes) {\n  // Each entry has the form [weight, nodeAIndex, nodeBIndex], where nodeAIndex < nodeBIndex\n  const result = [];\n\n  for (let i = 0; i < nodes.length; i++) {  // Calculate all n * (n - 1) / 2 edges\n    const nodeA = nodes[i];\n\n    for (let j = 0; j < i; j++) {\n      const nodeB = nodes[j];\n      let weight = Math.hypot(nodeA.posX - nodeB.posX, nodeA.posY - nodeB.posY);  // Euclidean distance\n      weight /= Math.pow(nodeA.radius * nodeB.radius, radiiWeightPower);  // Give discount based on node radii\n      result.push([weight, i, j]);\n    }\n  }\n\n  // Sort array by ascending weight\n  result.sort((a, b) => {\n    const [x] = a;\n    const [y] = b;\n    return x < y ? -1 : (x > y ? 1 : 0);\n  });\n\n  return result;\n}\n\n// Returns a new array of edge objects that is a minimal spanning tree on the given set\n// of nodes, with edges in ascending order of weight. Note that the returned edge objects\n// are missing the opacity property. Pure function, no side effects.\nexport function calcSpanningTree(allEdges, nodes) {\n\n  // Kruskal's MST algorithm\n  const result = [];\n  const ds = new DisjointSet(nodes.length);\n\n  for (let i = 0; i < allEdges.length && result.length < nodes.length - 1; i++) {\n    const edge = allEdges[i];\n    const j = edge[1];\n    const k = edge[2];\n\n    if (ds.mergeSets(j, k)) {\n      result.push({nodeA:nodes[j], nodeB:nodes[k]});\n    }\n  }\n\n  return result;\n}\n\n// Tests whether the given array of edge objects contains an edge with\n// the given endpoints (undirected). Pure function, no side effects.\nexport function containsEdge(array, edge) {\n  for (let i = 0; i < array.length; i++) {\n    const elem = array[i];\n    if (elem.nodeA == edge.nodeA && elem.nodeB == edge.nodeB || elem.nodeA == edge.nodeB && elem.nodeB == edge.nodeA) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n// Updates the position of each node in the given array (in place), based on\n// their existing positions. Returns nothing. No other side effects.\nexport function doForceField(nodes) {\n  let i = 0;\n  const deltas = [];\n\n  for (i = 0; i < nodes.length * 2; i++) {\n    deltas.push(0.0);\n  }\n\n  // For simplicitly, we perturb positions directly, instead of velocities\n  for (i = 0; i < nodes.length; i++) {\n    const nodeA = nodes[i];\n\n    for (let j = 0; j < i; j++) {\n      const nodeB = nodes[j];\n      let dx = nodeA.posX - nodeB.posX;\n      let dy = nodeA.posY - nodeB.posY;\n      const distSqr = dx * dx + dy * dy;\n\n      // Notes: The factor 1/sqrt(distSqr) is to make (dx, dy) into a unit vector.\n      // 1/distSqr is the inverse square law, with a smoothing constant added to prevent singularity.\n      const factor = repulsionForce / (Math.sqrt(distSqr) * (distSqr + 0.00001));\n      dx *= factor;\n      dy *= factor;\n      deltas[i * 2 + 0] += dx;\n      deltas[i * 2 + 1] += dy;\n      deltas[j * 2 + 0] -= dx;\n      deltas[j * 2 + 1] -= dy;\n    }\n  }\n\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].posX += deltas[i * 2 + 0];\n    nodes[i].posY += deltas[i * 2 + 1];\n  }\n}\n\n// Returns a new array of edges by reading the given array of nodes and by updating/adding/removing edges\n// based on the other given array. Although both argument arrays and nodes are unmodified,\n// the edge objects themselves are modified. No other side effects.\nexport function updateEdges(nodes, edges) {\n  let i = 0;\n\n  // Calculate array of spanning tree edges, then add some extra low-weight edges\n  let allEdges = calcAllEdgeWeights(nodes)\n  const idealEdges = calcSpanningTree(allEdges, nodes);\n\n  for (i = 0; i < allEdges.length && idealEdges.length < nodes.length - 1 + maxExtraEdges; i++) {\n    const edge = { nodeA:nodes[allEdges[i][1]], nodeB:nodes[allEdges[i][2]] };  // Convert data formats\n    if (!containsEdge(idealEdges, edge)) {\n      idealEdges.push(edge);\n    }\n  }\n  allEdges = null;  // Let this big array become garbage sooner\n\n  // Classify each current edge, checking whether it is in the ideal set; prune faded edges\n  const newEdges = [];\n  edges.forEach(function(edge) {\n    if (containsEdge(idealEdges, edge)) {\n      edge.opacity = Math.min(edge.opacity + FADE_IN_RATE, 1);\n    } else {\n      edge.opacity = Math.max(edge.opacity - FADE_OUT_RATE, 0);\n    }\n    if (edge.opacity > 0 && edge.nodeA.opacity > 0 && edge.nodeB.opacity > 0) {\n      newEdges.push(edge);\n    }\n  });\n\n  // If there is room for new edges, add some missing spanning tree edges (higher priority), then extra edges\n  for (i = 0; i < idealEdges.length && newEdges.length < nodes.length - 1 + maxExtraEdges; i++) {\n    const edge = idealEdges[i];\n    if (!containsEdge(newEdges, edge)) {\n      edge.opacity = 0.0;  // Add missing property\n      newEdges.push(edge);\n    }\n  }\n\n  return newEdges;\n}\n\n// Redraws the canvas based on the given values. No other side effects.\nexport function redrawCanvas(canvasElem, graphics, nodes, edges) {\n\n  // Get pixel dimensions\n  const { width, height } = canvasElem;\n  const size = Math.max(width, height);\n\n  // Draw background gradient to overwrite everything\n  const gradient = graphics.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, size / 2);\n  gradient.addColorStop(0.0, '#575E85');\n  gradient.addColorStop(1.0, '#2E3145');\n  graphics.fillStyle = gradient;\n  graphics.fillRect(0, 0, width, height);\n\n  // Draw every node\n  nodes.forEach((node) => {\n    graphics.fillStyle = `rgba(129,139,197,${node.opacity.toFixed(3)})`;\n    graphics.beginPath();\n    graphics.arc(node.posX * size, node.posY * size, node.radius * size, 0, Math.PI * 2);\n    graphics.fill();\n  });\n\n  // Draw every edge\n  graphics.lineWidth = size / 800;\n  edges.forEach((edge) => {\n    const { nodeA, nodeB } = edge;\n    let dx = nodeA.posX - nodeB.posX;\n    let dy = nodeA.posY - nodeB.posY;\n    const mag = Math.hypot(dx, dy);\n\n    if (mag > nodeA.radius + nodeB.radius) {  // Draw edge only if circles don't intersect\n      dx /= mag;  // Make (dx, dy) a unit vector, pointing from B to A\n      dy /= mag;\n\n      const opacity = Math.min(Math.min(nodeA.opacity, nodeB.opacity), edge.opacity);\n      graphics.strokeStyle = `rgba(129,139,197,${opacity.toFixed(3)})`;\n      graphics.beginPath();\n\n      // Shorten the edge so that it only touches the circumference of each circle\n      graphics.moveTo((nodeA.posX - dx * nodeA.radius) * size, (nodeA.posY - dy * nodeA.radius) * size);\n      graphics.lineTo((nodeB.posX + dx * nodeB.radius) * size, (nodeB.posY + dy * nodeB.radius) * size);\n      graphics.stroke();\n    }\n  });\n}\n","import nayukiCanvas from './nayuki-canvas';\n\nif (typeof exports === 'object') {\n  module.exports = nayukiCanvas;\n} else if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n  define(function() { return nayukiCanvas; });\n} else if (window && !window.nayukiCanvas) {\n  window.nayukiCanvas = nayukiCanvas;\n}\n"],"sourceRoot":"/source/"}