{"version":3,"sources":["nayuki-canvas.js","core/update-nodes.js","disjoint-set.js","utils.js","core/update-edges.js","core/do-force-field.js","core/redraw-canvas.js","core/initialize.js","index.js","core/core.js"],"names":["updateNodes","_this","this","pixWidth","canvasElem","clientWidth","pixHeight","clientHeight","nodes","relWidth","Math","max","relHeight","newNodes","forEach","node","index","posX","velX","driftSpeed","posY","velY","random","idealNumNodes","config","BORDER_FADE","opacity","FADE_OUT_RATE","min","FADE_IN_RATE","push","i","length","radius","pow","doForceField","DisjointSet","size","getRepr","parents","ranks","mergeSets","j","repr0","repr1","cmp","containsEdge","array","edge","elem","nodeA","nodeB","calcSpanningTree","allEdges","result","ds","k","calcAllEdgeWeights","radiiWeightPower","weight","hypot","sort","a","b","_a","_slicedToArray","x","_b","y","updateEdges","_this2","edges","idealEdges","maxExtraEdges","newEdges","_edge","deltas","repulsionForce","dx","dy","distSqr","factor","sqrt","redrawCanvas","graphics","width","height","gradient","createRadialGradient","addColorStop","fillStyle","fillRect","toFixed","beginPath","arc","PI","fill","lineWidth","mag","strokeStyle","moveTo","lineTo","stroke","initialize","stepFrame","concat","item","_typeof","Symbol","iterator","obj","constructor","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","next","done","value","err","Array","isArray","Object","TypeError","nayukiCore","networkStyleKey","mesh","balanced","hubAndSpoke","nayukiCanvas","create","options","HTMLElement","nodeName","Error","assign","extraEdges","numNodes","networkStyle","FRAME_INTERVAL","proto","canvas","get","parseInt","_config","round","parseFloat","isNaN","set","getContext","setInterval","exports","module","define","amd","window"],"mappings":"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","file":"nayuki-canvas.min.js","sourcesContent":["import nayukiCore from './core/core'\n\nconst networkStyleKey = {\n  mesh: 0,\n  balanced: 0.5,\n  hubAndSpoke: 1\n};\n\nconst nayukiCanvas = {\n  create(canvasElem, options) {\n\n    if (canvasElem instanceof HTMLElement === false || canvasElem.nodeName !== 'CANVAS') {\n      throw new Error('Nayuki Canvas requires a canvas DOM node as the first argument');\n    }\n\n    // Overwrite config with user options\n    const config = Object.assign({\n      extraEdges: 20,\n      numNodes: 70,\n      networkStyle: 'balanced',\n      driftSpeed: 1,\n      repulsionForce: 1,\n      BORDER_FADE: -0.02,\n      FADE_IN_RATE: 0.06,  // In the range (0.0, 1.0]\n      FADE_OUT_RATE: 0.03,  // In the range (0.0, 1.0]\n      FRAME_INTERVAL: 20  // In milliseconds\n    }, options);\n    const proto = Object.assign({}, { config }, nayukiCore);\n    const canvas = Object.create(proto, {\n      idealNumNodes: {\n        get() {\n          return parseInt(this.config.numNodes, 10);\n        }\n      },\n      maxExtraEdges: {\n        get() {\n          const { extraEdges, numNodes } = this.config;\n          return Math.round(parseFloat(extraEdges) / 100 * numNodes);\n        }\n      },\n      radiiWeightPower: {\n        get() {\n          const { networkStyle } = this.config;\n          const radiiWeightPower = networkStyleKey[networkStyle];\n          return parseFloat(radiiWeightPower);\n        }\n      },\n      driftSpeed: {\n        get() {\n          const driftSpeed = this.config.driftSpeed;\n          if (!isNaN(driftSpeed)) {\n            return driftSpeed * 0.0001;\n          } else {\n            return driftSpeed;\n          }\n        },\n        set(value) {\n          this.config.driftSpeed = parseFloat(value);\n          return this.driftSpeed;\n        }\n      },\n      repulsionForce: {\n        get() {\n          const repulsionForce = this.config.repulsionForce;\n          if (!isNaN(repulsionForce)) {\n            return repulsionForce * 0.000001;\n          } else {\n            return repulsionForce;\n          }\n        },\n        set(value) {\n          this.config.repulsionForce = parseFloat(value);\n          return this.repulsionForce;\n        }\n      }\n    });\n    canvas.canvasElem = canvasElem;\n\n    // Initialize canvas and inputs\n    const graphics = canvas.graphics = canvasElem.getContext('2d');\n\n    // State of graph nodes - each object has these properties:\n    // - posX: Horizontal position in relative coordinates, typically in the range [0.0, relWidth], where relWidth <= 1.0\n    // - posY: Vertical position in relative coordinates, typically in the range [0.0, relHeight], where relHeight <= 1.0\n    // - velX: Horizontal velocity in relative units (not pixels)\n    // - velY: Vertical velocity in relative units (not pixels)\n    // - radius: Radius of the node, a positive real number\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the node\n    canvas.nodes = [];\n\n    // State of graph edges - each object has these properties:\n    // - nodeA: A reference to the node object representing one side of the undirected edge\n    // - nodeB: A reference to the node object representing another side of the undirected edge (must be distinct from NodeA)\n    // - opacity: A number in the range [0.0, 1.0] representing the strength of the edge\n    canvas.edges = [];\n\n    // This important top-level function updates the arrays of nodes and edges, then redraws the canvas.\n    // We define it within the closure to give it access to key variables that persist across iterations.\n    canvas.stepFrame = function stepFrame() {\n      const { canvasElem, graphics } = this;\n      this.nodes = this.updateNodes();\n      this.edges = this.updateEdges();\n      this.redrawCanvas();\n    };\n\n    canvas.initialize();\n\n    // Periodically execute stepFrame() to create animation\n    setInterval(() => canvas.stepFrame(), config.FRAME_INTERVAL);\n    return canvas;\n  }\n};\n\nexport default nayukiCanvas;\n","/*\n* Returns a new array of nodes by updating/adding/removing nodes based on the given array. Although the\n* argument array is not modified, the node objects themselves are modified. No other side effects.\n*/\nexport default function updateNodes() {\n  const pixWidth = this.canvasElem.clientWidth\n  const pixHeight = this.canvasElem.clientHeight\n  const { nodes } = this;\n\n  // At least one of relWidth or relHeight is exactly 1. The aspect ratio relWidth:relHeight is equal to w:h.\n  const relWidth  = pixWidth  / Math.max(pixWidth, pixHeight);\n  const relHeight = pixHeight / Math.max(pixWidth, pixHeight);\n\n  // Update position, velocity, opacity; prune faded nodes\n  const newNodes = [];\n  nodes.forEach((node, index) => {\n\n    // Move based on velocity\n    node.posX += node.velX * this.driftSpeed;\n    node.posY += node.velY * this.driftSpeed;\n\n    // Randomly perturb velocity, with damping\n    node.velX = node.velX * 0.99 + (Math.random() - 0.5) * 0.3;\n    node.velY = node.velY * 0.99 + (Math.random() - 0.5) * 0.3;\n\n    // Fade out nodes near the borders of the space or exceeding the target number of nodes\n    if (index >= this.idealNumNodes || node.posX < this.config.BORDER_FADE || relWidth - node.posX < this.config.BORDER_FADE || node.posY < this.config.BORDER_FADE || relHeight - node.posY < this.config.BORDER_FADE) {\n      node.opacity = Math.max(node.opacity - this.config.FADE_OUT_RATE, 0);\n    } else { // Fade in ones otherwise\n      node.opacity = Math.min(node.opacity + this.config.FADE_IN_RATE, 1);\n    }\n\n    if (node.opacity > 0) {\n\n      // Only keep visible nodes\n      newNodes.push(node);\n    }\n  });\n\n  // Add new nodes to fade in\n  for (let i = newNodes.length; i < this.idealNumNodes; i++) {\n    newNodes.push({ // Random position and radius, other properties initially zero\n      posX: Math.random() * relWidth,\n      posY: Math.random() * relHeight,\n      radius: (Math.pow(Math.random(), 5) + 0.35) * 0.015,  // Skew toward smaller values\n      velX: 0.0,\n      velY: 0.0,\n      opacity: 0.0,\n    });\n  }\n\n  // Spread out nodes a bit\n  this.doForceField();\n\n  return newNodes;\n}\n","// The union-find data structure. A heavily stripped-down version derived from https://www.nayuki.io/page/disjoint-set-data-structure .\nexport default function DisjointSet(size) {\n  const parents = [];\n  const ranks = [];\n\n  for (let i = 0; i < size; i++) {\n    parents.push(i);\n    ranks.push(0);\n  }\n\n  function getRepr(i) {\n    if (parents[i] != i) {\n      parents[i] = getRepr(parents[i]);\n    }\n    return parents[i];\n  }\n\n  this.mergeSets = function(i, j) {\n    const repr0 = getRepr(i);\n    const repr1 = getRepr(j);\n\n    if (repr0 == repr1) {\n      return false;\n    }\n\n    const cmp = ranks[repr0] - ranks[repr1];\n    if (cmp >= 0) {\n      if (cmp == 0) {\n        ranks[repr0]++;\n      }\n      parents[repr1] = repr0;\n    } else {\n      parents[repr0] = repr1;\n    }\n\n    return true;\n  };\n}\n","import DisjointSet from './disjoint-set'\n\n// Tests whether the given array of edge objects contains an edge with\n// the given endpoints (undirected). Pure function, no side effects.\nexport function containsEdge(array, edge) {\n  for (let i = 0; i < array.length; i++) {\n    const elem = array[i]\n    if (elem.nodeA == edge.nodeA && elem.nodeB == edge.nodeB || elem.nodeA == edge.nodeB && elem.nodeB == edge.nodeA) {\n      return true\n    }\n  }\n  return false\n}\n\n// Returns a new array of edge objects that is a minimal spanning tree on the given set\n// of nodes, with edges in ascending order of weight. Note that the returned edge objects\n// are missing the opacity property. Pure function, no side effects.\nexport function calcSpanningTree(allEdges, nodes) {\n\n  // Kruskal's MST algorithm\n  const result = []\n  const ds = new DisjointSet(nodes.length)\n\n  for (let i = 0; i < allEdges.length && result.length < nodes.length - 1; i++) {\n    const edge = allEdges[i]\n    const j = edge[1]\n    const k = edge[2]\n\n    if (ds.mergeSets(j, k)) {\n      result.push({ nodeA: nodes[j], nodeB: nodes[k] })\n    }\n  }\n\n  return result\n}\n\n// Returns a sorted array of edges with weights, for all unique edge pairs. Pure function, no side effects.\nexport function calcAllEdgeWeights(nodes, radiiWeightPower) {\n\n  // Each entry has the form [weight, nodeAIndex, nodeBIndex], where nodeAIndex < nodeBIndex\n  const result = []\n\n  for (let i = 0; i < nodes.length; i++) {  // Calculate all n * (n - 1) / 2 edges\n    const nodeA = nodes[i]\n\n    for (let j = 0; j < i; j++) {\n      const nodeB = nodes[j]\n      let weight = Math.hypot(nodeA.posX - nodeB.posX, nodeA.posY - nodeB.posY)  // Euclidean distance\n      weight /= Math.pow(nodeA.radius * nodeB.radius, radiiWeightPower)  // Give discount based on node radii\n      result.push([weight, i, j])\n    }\n  }\n\n  // Sort array by ascending weight\n  result.sort((a, b) => {\n    const [x] = a\n    const [y] = b\n    return x < y ? -1 : (x > y ? 1 : 0)\n  });\n\n  return result\n}\n","import { calcAllEdgeWeights, calcSpanningTree, containsEdge } from '../utils'\n\n/*\n* Returns a new array of edges by reading the given array of nodes and by updating/adding/removing edges\n* based on the other given array. Although both argument arrays and nodes are unmodified,\n* the edge objects themselves are modified. No other side effects.\n*/\nexport default function updateEdges() {\n  let i = 0;\n  const { nodes, edges } = this;\n\n  // Calculate array of spanning tree edges, then add some extra low-weight edges\n  let allEdges = calcAllEdgeWeights(nodes, this.radiiWeightPower)\n  const idealEdges = calcSpanningTree(allEdges, nodes);\n\n  for (i = 0; i < allEdges.length && idealEdges.length < nodes.length - 1 + this.maxExtraEdges; i++) {\n    const edge = { nodeA: nodes[allEdges[i][1]], nodeB: nodes[allEdges[i][2]] };  // Convert data formats\n    if (!containsEdge(idealEdges, edge)) {\n      idealEdges.push(edge);\n    }\n  }\n  allEdges = null;  // Let this big array become garbage sooner\n\n  // Classify each current edge, checking whether it is in the ideal set; prune faded edges\n  const newEdges = [];\n  edges.forEach((edge) => {\n    if (containsEdge(idealEdges, edge)) {\n      edge.opacity = Math.min(edge.opacity + this.config.FADE_IN_RATE, 1);\n    } else {\n      edge.opacity = Math.max(edge.opacity - this.config.FADE_OUT_RATE, 0);\n    }\n    if (edge.opacity > 0 && edge.nodeA.opacity > 0 && edge.nodeB.opacity > 0) {\n      newEdges.push(edge);\n    }\n  });\n\n  // If there is room for new edges, add some missing spanning tree edges (higher priority), then extra edges\n  for (i = 0; i < idealEdges.length && newEdges.length < nodes.length - 1 + this.maxExtraEdges; i++) {\n    const edge = idealEdges[i];\n    if (!containsEdge(newEdges, edge)) {\n      edge.opacity = 0.0;  // Add missing property\n      newEdges.push(edge);\n    }\n  }\n\n  return newEdges;\n}\n","/*\n* Updates the position of each node in the given array (in place), based on\n* their existing positions. Returns nothing. No other side effects.\n*/\nexport default function doForceField() {\n  let i = 0;\n  const deltas = [];\n  const { repulsionForce, nodes } = this;\n\n  for (i = 0; i < nodes.length * 2; i++) {\n    deltas.push(0.0);\n  }\n\n  // For simplicitly, we perturb positions directly, instead of velocities\n  for (i = 0; i < nodes.length; i++) {\n    const nodeA = nodes[i];\n\n    for (let j = 0; j < i; j++) {\n      const nodeB = nodes[j];\n      let dx = nodeA.posX - nodeB.posX;\n      let dy = nodeA.posY - nodeB.posY;\n      const distSqr = dx * dx + dy * dy;\n\n      // Notes: The factor 1/sqrt(distSqr) is to make (dx, dy) into a unit vector.\n      // 1/distSqr is the inverse square law, with a smoothing constant added to prevent singularity.\n      const factor = repulsionForce / (Math.sqrt(distSqr) * (distSqr + 0.00001));\n      dx *= factor;\n      dy *= factor;\n      deltas[i * 2 + 0] += dx;\n      deltas[i * 2 + 1] += dy;\n      deltas[j * 2 + 0] -= dx;\n      deltas[j * 2 + 1] -= dy;\n    }\n  }\n\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].posX += deltas[i * 2 + 0];\n    nodes[i].posY += deltas[i * 2 + 1];\n  }\n}\n","// Redraws the canvas based on the given values. No other side effects.\nexport default function redrawCanvas() {\n  const { canvasElem, graphics, nodes, edges } = this;\n\n  // Get pixel dimensions\n  const { width, height } = canvasElem;\n  const size = Math.max(width, height);\n\n  // Draw background gradient to overwrite everything\n  const gradient = graphics.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, size / 2);\n  gradient.addColorStop(0.0, '#575E85');\n  gradient.addColorStop(1.0, '#2E3145');\n  graphics.fillStyle = gradient;\n  graphics.fillRect(0, 0, width, height);\n\n  // Draw every node\n  nodes.forEach((node) => {\n    graphics.fillStyle = `rgba(129,139,197,${node.opacity.toFixed(3)})`;\n    graphics.beginPath();\n    graphics.arc(node.posX * size, node.posY * size, node.radius * size, 0, Math.PI * 2);\n    graphics.fill();\n  });\n\n  // Draw every edge\n  graphics.lineWidth = size / 800;\n  edges.forEach((edge) => {\n    const { nodeA, nodeB } = edge;\n    let dx = nodeA.posX - nodeB.posX;\n    let dy = nodeA.posY - nodeB.posY;\n    const mag = Math.hypot(dx, dy);\n\n    if (mag > nodeA.radius + nodeB.radius) {  // Draw edge only if circles don't intersect\n      dx /= mag;  // Make (dx, dy) a unit vector, pointing from B to A\n      dy /= mag;\n\n      const opacity = Math.min(Math.min(nodeA.opacity, nodeB.opacity), edge.opacity);\n      graphics.strokeStyle = `rgba(129,139,197,${opacity.toFixed(3)})`;\n      graphics.beginPath();\n\n      // Shorten the edge so that it only touches the circumference of each circle\n      graphics.moveTo((nodeA.posX - dx * nodeA.radius) * size, (nodeA.posY - dy * nodeA.radius) * size);\n      graphics.lineTo((nodeB.posX + dx * nodeB.radius) * size, (nodeB.posY + dy * nodeB.radius) * size);\n      graphics.stroke();\n    }\n  });\n}\n","// Populate initial nodes and edges, then improve on them\nexport default function initialize() {\n  this.stepFrame();  // Generate nodes\n  for (let i = 0; i < 300; i++) {  // Spread out nodes to avoid ugly clumping\n    this.doForceField();\n  }\n  this.edges = [];\n  this.stepFrame();  // Redo spanning tree and extra edges because nodes have moved\n\n  // Make everything render immediately instead of fading in\n  this.nodes.concat(this.edges).forEach(function(item) {  // Duck typing\n    item.opacity = 1;\n  });\n\n  this.redrawCanvas();\n}\n","import nayukiCanvas from './nayuki-canvas';\n\nif (typeof exports === 'object') {\n  module.exports = nayukiCanvas;\n} else if (typeof define === 'function' && typeof define.amd !== 'undefined') {\n  define(function() { return nayukiCanvas; });\n} else if (window && !window.nayukiCanvas) {\n  window.nayukiCanvas = nayukiCanvas;\n}\n","import updateNodes from './update-nodes'\nimport updateEdges from './update-edges'\nimport doForceField from './do-force-field'\nimport redrawCanvas from './redraw-canvas'\nimport initialize from './initialize'\n\nexport default {\n  updateNodes,\n  updateEdges,\n  doForceField,\n  redrawCanvas,\n  initialize\n}\n"],"sourceRoot":"/source/"}